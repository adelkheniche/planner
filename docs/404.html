 <!doctype html>
<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Planning D.U 17</title>

    <!-- Tailwind (CDN, pas de build) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React 18 UMD + Babel pour JSX dans le navigateur -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Supabase (UMD build via CDN) -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>

    <!-- Local helpers -->
    <script src="identity.js"></script>

    <!-- Markdown parser -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <meta name="color-scheme" content="light" />
    <link rel="stylesheet" href="faclab.css" />
    <style>
      html { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
      .task-bar { font-size: var(--task-font,11px); transition: box-shadow .08s ease; }
      .task-bar.is-dragging { opacity:0.9; z-index:50; cursor:grabbing; }
      .task-bar.hide-bullet .bullet { display:none; }
      .task-bar.remote-moving { outline: 2px dashed currentColor; }
      body.is-dragging { cursor:grabbing; user-select:none; }
    </style>
  </head>
    <body>
       <div id="root"></div>
      <script type="text/babel" data-presets="env,react">
/* ===========================================================
   GANTT collaboratif (presence + broadcast + BDD realtime)
   =========================================================== */

const { PALETTE, NAMES, ID_KEY } = window.Identity;

const { useEffect, useMemo, useRef, useState } = React;

/* ---------- Supabase ---------- */
const CFG = {
  url: "https://kadoikpkjmkchabvnuqs.supabase.co",
  anonKey: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImthZG9pa3Bram1rY2hhYnZudXFzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzMzEwNDIsImV4cCI6MjA3MDkwNzA0Mn0.q28StZ8nsrbck2Xx6xBCfpgdfLotxne3cyWc6-o_FZM",
  slug: "main",
  room: "planner_room_main"
};
let supabase = null;
if (window.supabase && typeof window.supabase.createClient === "function") {
  supabase = window.supabase.createClient(CFG.url, CFG.anonKey);
} else {
  console.error("[Planner] Supabase JS v2 non chargé (CDN).");
}

/* ---------- Identité (pseudo + couleur) ---------- */
let IDENTITY = null;
try {
  IDENTITY = JSON.parse(localStorage.getItem(ID_KEY) || "null");
} catch {}
if (!IDENTITY) {
  const pseudo = NAMES[Math.floor(Math.random() * NAMES.length)];
  const color  = PALETTE[Math.floor(Math.random() * PALETTE.length)];
  const id     = (crypto?.randomUUID && crypto.randomUUID()) || String(Date.now());
  IDENTITY = { id, pseudo, color };
  localStorage.setItem(ID_KEY, JSON.stringify(IDENTITY));
}

/* ---------- Constantes UI / temps ---------- */
const WEEK_STARTS_ON = 1;             // lundi
const MS_DAY = 24*60*60*1000;
const COL_W_MIN = 44;                 // largeur minimale d’une semaine (px)
const ROW_H = 26;                     // hauteur d’une ligne (px)
const ROW_GAP = 2;                    // petit padding vertical dans une ligne
const SUB_ROW_H = 22;                 // hauteur d'une voie dans la sous-frise
const SUB_ROW_GAP = 2;                // marge interne des sous-barres
const DRAG_THRESHOLD_PX = 6;
const DRAG_THRESHOLD_MS = 120;
const BULLET_HIDE_W = 48;
const fmtMonthYear = new Intl.DateTimeFormat("fr-FR",{ month:"long", year:"numeric" });
const fmtDM = new Intl.DateTimeFormat("fr-FR",{ day:"numeric", month:"short" });

/* ---------- Helpers ---------- */
const throttle = (fn, ms=50) => {
  let last = 0, to=null;
  return (...args) => {
    const now = Date.now();
    const run = () => { last = now; fn(...args); };
    if (now - last >= ms) run();
    else { clearTimeout(to); to = setTimeout(run, ms - (now - last)); }
  };
};

function startOfWeek(d, w=WEEK_STARTS_ON){ const x=new Date(d.getFullYear(),d.getMonth(),d.getDate()); const day=x.getDay(); const diff=(day-w+7)%7; x.setDate(x.getDate()-diff); x.setHours(0,0,0,0); return x; }
function endOfWeek(d, w=WEEK_STARTS_ON){ const s=startOfWeek(d,w); const e=new Date(s.getTime()+MS_DAY*6); e.setHours(23,59,59,999); return e; }
function clampDate(d,minD,maxD){ if(d<minD) return new Date(minD); if(d>maxD) return new Date(maxD); return d; }
function toISODate(d){ const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,"0"); const dd=String(d.getDate()).padStart(2,"0"); return `${y}-${m}-${dd}`; }
function addWeeksISO(iso,n,minD,maxD){ const d=new Date(iso); d.setDate(d.getDate()+7*n); return toISODate(clampDate(d,minD,maxD)); }
function getISOWeek(date){ const d=new Date(Date.UTC(date.getFullYear(),date.getMonth(),date.getDate())); const dayNum=d.getUTCDay()||7; d.setUTCDate(d.getUTCDate()+4-dayNum); const yearStart=new Date(Date.UTC(d.getUTCFullYear(),0,1)); return Math.ceil(((d-yearStart)/MS_DAY+1)/7); }
const TIMELINE_START = startOfWeek(new Date(2025,8,1));
const TIMELINE_END   = endOfWeek(new Date(2026,0,31));

function eachWeekOfInterval(start,end){
  const weeks=[]; let cur=startOfWeek(start); const endW=startOfWeek(end);
  while(cur<=endW){ weeks.push(new Date(cur)); const next=new Date(cur); next.setDate(next.getDate()+7); cur=startOfWeek(next); if(weeks.length>400) break; }
  return weeks;
}

/* ---------- Local cache + transfert ---------- */
const LS_KEY = "gantt-sept2025-fev2026";
function loadState(){ try{ const raw=localStorage.getItem(LS_KEY); return raw?JSON.parse(raw):null; }catch{ return null; } }
function saveState(state){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)); }catch{} }
function b64Encode(str){ try{ return btoa(unescape(encodeURIComponent(str))); }catch{ return btoa(str);} }
function b64Decode(str){ try{ return decodeURIComponent(escape(atob(str))); }catch{ return atob(str);} }
(function importFromHash(){
  try{
    const h=location.hash;
    if(h && h.startsWith("#s=")){
      const s=JSON.parse(b64Decode(h.slice(3)));
      if(s) localStorage.setItem(LS_KEY, JSON.stringify({categories:s.categories||[],tasks:s.tasks||[]}));
      history.replaceState(null,"", location.pathname+location.search);
    }
  }catch(e){ console.warn("State-from-hash failed", e); }
})();

/* ---------- Utils Gantt ---------- */
function weekIndexOf(date, weeks){
  const s = startOfWeek(clampDate(date, TIMELINE_START, TIMELINE_END));
  const idx = weeks.findIndex(w=>w.getTime()===s.getTime());
  return idx<0 ? weeks.length-1 : idx;
}
function taskGridInfo(task, weeks, colW){
  const sIdx = weekIndexOf(new Date(task.startISO), weeks);
  const eIdx = weekIndexOf(new Date(task.endISO),   weeks);
  const span = Math.max(1, eIdx - sIdx + 1);
  return { sIdx, eIdx, span, left: sIdx*colW, width: span*colW };
}

/* ---------- Packing sous-tâches ---------- */
function packLanes(children, weeks, colW){
  const items = children
    .map(t => ({ t, ...taskGridInfo(t, weeks, colW) }))
    .sort((a,b) => a.sIdx - b.sIdx || a.eIdx - b.eIdx);

  const lanes = []; // chaque lane = dernier eIdx
  const placed = items.map(it => {
    let lane = 0;
    for(; lane < lanes.length; lane++){
      if (it.sIdx > lanes[lane]) break; // pas de chevauchement
    }
    if (lane === lanes.length) lanes.push(-1);
    lanes[lane] = Math.max(lanes[lane], it.eIdx);
    return { ...it, lane };
  });

  const lanesCount = Math.max(1, lanes.length || 1);
  return { lanesCount, placed };
}

function fontPxFor(width, title){
  const charW = 0.6;
  const px = width / (charW * Math.max(1, title.length));
  return Math.max(8, Math.min(12, px));
}

/* ---------- Composant ---------- */
function PlannerApp(){
  const weeks = useMemo(()=>eachWeekOfInterval(TIMELINE_START, TIMELINE_END),[]);
  const visibleWeeks = useMemo(
    ()=>weeks.filter(w=>!(w.getFullYear()===2026 && w.getMonth()===1)),
    [weeks]
  );
  const monthSegments = useMemo(()=>{
    if(visibleWeeks.length===0) return [];
    const segs=[]; let currentLabel=fmtMonthYear.format(new Date(visibleWeeks[0].getTime()+MS_DAY*3)); let span=0;
    for(let i=0;i<visibleWeeks.length;i++){
      const label=fmtMonthYear.format(new Date(visibleWeeks[i].getTime()+MS_DAY*3));
      if(label===currentLabel) span++;
      else { segs.push({label:currentLabel,span}); currentLabel=label; span=1; }
    }
    segs.push({label:currentLabel,span}); return segs;
  },[visibleWeeks]);

  // état initial
  const initial = loadState();
  const [categories,setCategories] = useState(initial?.categories || []);
  // task: {id,title,startISO,endISO,color,categoryId,row,notes[],parentId?,expanded?}
  const [tasks,setTasks] = useState((initial?.tasks || []).map((t,i)=>({
    ...t,
    row: typeof t.row==='number' ? t.row : i,
    notes: Array.isArray(t.notes) ? t.notes : [],
    expanded: !!t.expanded,
    parentId: t.parentId || null
  })));
  const [selectedTaskId,setSelectedTaskId] = useState(null);
  const [newNote,setNewNote] = useState("");
  const dragHappenedRef = useRef(false);
  const selectedTask = useMemo(
    ()=>tasks.find(t=>t.id===selectedTaskId) || null,
    [selectedTaskId,tasks]
  );
  const [panelOpen,setPanelOpen] = useState(false);
  const [notesOpen,setNotesOpen] = useState(true);
  const [colW,setColW] = useState(COL_W_MIN);

  /* ---------- Collaboration: Presence + Broadcast ---------- */
  // Show local pseudonym even if realtime channel is unavailable
  const [presence, setPresence] = useState([
    { id: IDENTITY.id, pseudo: IDENTITY.pseudo, color: IDENTITY.color }
  ]); // [{id,pseudo,color}]
  const chanRef = useRef(null);                           // realtime channel
  const ghostRef = useRef(new Map());                    // taskId -> {from,deltaWeeks,color}

  // Abonnement presence + broadcast (drag live)
  useEffect(()=>{
    if (!supabase) return;
    const ch = supabase.channel(CFG.room, { config: { presence: { key: IDENTITY.id } } });

    ch.on("presence", { event: "sync" }, () => {
      const st = ch.presenceState();
      const flat = [];
      for (const [id, arr] of Object.entries(st)) {
        const last = arr[arr.length-1];
        if (last) flat.push({ id, pseudo:last.pseudo, color:last.color });
      }
      if (!flat.some(p => p.id === IDENTITY.id)) {
        flat.push({ id: IDENTITY.id, pseudo: IDENTITY.pseudo, color: IDENTITY.color });
      }
      setPresence(flat);
    });

    ch.on("broadcast", { event: "drag" }, ({ payload }) => {
      const { t, taskId, from, deltaWeeks=0, by, color } = payload || {};
      if (!taskId || from === IDENTITY.id) return;

      const el = document.querySelector(`.task-bar[data-taskid="${CSS.escape(taskId)}"]`);
      if (!el) return;

      el.style.color = color || el.style.color;
      if (t === "start") {
        el.classList.add("remote-moving");
        ghostRef.current.set(taskId, { from, deltaWeeks:0, color });
      } else if (t === "move") {
        const g = ghostRef.current.get(taskId) || { from, deltaWeeks:0, color };
        g.deltaWeeks = deltaWeeks;
        ghostRef.current.set(taskId, g);
        const px = deltaWeeks * colW;
        el.style.transform = `translate3d(${px}px,0,0)`;
      } else if (t === "end") {
        ghostRef.current.delete(taskId);
        el.classList.remove("remote-moving");
        el.style.transform = "";
      }
    });

    ch.subscribe(async (status) => {
      if (status === "SUBSCRIBED") {
        await ch.track({ pseudo: IDENTITY.pseudo, color: IDENTITY.color });
      }
    });

    chanRef.current = ch;
    return () => { try { supabase.removeChannel(ch); } catch {} };
  }, [colW]);

  /* ---------- Realtime BDD sur planner_state ---------- */
  useEffect(()=>{
    if (!supabase) return;
    // IMPORTANT : exécuter côté Supabase :
    // ALTER PUBLICATION supabase_realtime ADD TABLE public.planner_state;
    const ch = supabase.channel("db-" + CFG.room)
      .on("postgres_changes",
        { event:"*", schema:"public", table:"planner_state", filter:`slug=eq.${CFG.slug}` },
        (payload) => {
          const row = payload.new || payload.old;
          if (!row || !row.data) return;
          const s = row.data;
          // Recharge l'état reçu (dernière écriture)
          if (s.categories) setCategories(s.categories);
          if (s.tasks) {
            setTasks(s.tasks.map((t,i)=>({
              ...t,
              row: typeof t.row==='number' ? t.row : i,
              notes: Array.isArray(t.notes) ? t.notes : [],
              expanded: !!t.expanded,
              parentId: t.parentId || null
            })));
          }
        }
      )
      .subscribe();
    return ()=>{ try { supabase.removeChannel(ch); } catch {} };
  }, []);

  // synchro initiale depuis BDD
  useEffect(()=>{
    if (!supabase) return;
    (async ()=>{
      try{
        const { data, error } = await supabase
          .from("planner_state")
          .select("data")
          .eq("slug", CFG.slug)
          .maybeSingle();
        if(error) { console.warn("Supabase select error:", error.message); return; }
        if(data?.data){
          const s=data.data;
          if(s.categories) setCategories(s.categories);
          if(s.tasks){
            setTasks(s.tasks.map((t,i)=>({
              ...t,
              row: typeof t.row==='number' ? t.row : i,
              notes: Array.isArray(t.notes) ? t.notes : [],
              expanded: !!t.expanded,
              parentId: t.parentId || null
            })));
          }
        }
      }catch{}
      })();
  },[]);

  // sauvegarde locale
  useEffect(()=>{ saveState({categories,tasks}); },[categories,tasks]);

  // upsert debouncé vers BDD (toutes modifs)
  useEffect(()=>{
    if (!supabase) return;
    const payload={categories,tasks, last_by: IDENTITY.pseudo};
    const t=setTimeout(async ()=>{
      try{
        await supabase.from("planner_state").upsert({slug:CFG.slug, data:payload, updated_at:new Date().toISOString()});
      }catch(e){ console.warn("upsert error", e?.message); }
    }, 600);
    return ()=>clearTimeout(t);
  },[categories,tasks]);

  /* --------- Filtres de catégories --------- */
  const enabledCategoryIds = useMemo(
    ()=> new Set(categories.filter(c=>c.enabled!==false).map(c=>c.id)),
    [categories]
  );
  const filteredTop = useMemo(()=>{
    const top = tasks.filter(t => !t.parentId);
    if(!categories.length) return top;
    return top.filter(t => !t.categoryId || enabledCategoryIds.has(t.categoryId));
  }, [tasks, categories, enabledCategoryIds]);

  /* --------- LAYOUT des lignes (principal + sous-frises) --------- */
  const layoutRows = useMemo(() => {
    const rows = [];
    if (!filteredTop || filteredTop.length === 0) return rows;

    const maxTopRow = Math.max(0, ...filteredTop.map(t => (typeof t.row === 'number' ? t.row : 0)));
    const topByRow = new Map();

    for (let r = 0; r <= maxTopRow; r++) {
      const rowTasks = filteredTop.filter(t => (t.row || 0) === r);
      topByRow.set(r, rowTasks);
    }

    for (let r = 0; r <= maxTopRow; r++) {
      rows.push({ type: 'main', row: r });
      const rowTasks = topByRow.get(r) || [];

      for (const p of rowTasks) {
        if (!p.expanded) continue;
        const children = tasks.filter(t => t.parentId === p.id);
        const { lanesCount } = packLanes(children, visibleWeeks, colW);
        rows.push({ type: 'sub', parentId: p.id, lanesCount });
      }
    }

    return rows;
  }, [filteredTop, tasks, visibleWeeks, colW]);

  /* --------- DnD --------- */
  const dragRef = useRef(null);
  const rafRef = useRef(null);
  const subZonesRef = useRef({});
  const containerRef = useRef(null);
  const scrollRef = useRef(null);
  const lastWasDblClickRef = useRef(false);

  useEffect(()=>{
    const update = () => {
      const el = containerRef.current;
      if(!el) return;
      const w = el.clientWidth;
      setColW(Math.max(COL_W_MIN, Math.floor(w / visibleWeeks.length)));
    };
    update();
    const ro = new ResizeObserver(update);
    if(containerRef.current) ro.observe(containerRef.current);
    window.addEventListener('resize', update);
    return ()=>{
      ro.disconnect();
      window.removeEventListener('resize', update);
    };
  }, [visibleWeeks.length]);

  // recalcul zones sous-frises
  useEffect(()=>{
    const update = () => {
      const map = {};
      const nodes = document.querySelectorAll("[data-subzone='1']");
      nodes.forEach(n=>{
        const pid = n.getAttribute("data-parentid");
        if(pid) map[pid] = n.getBoundingClientRect();
      });
      subZonesRef.current = map;
    };
    update();
    const ro = new ResizeObserver(update);
    if(containerRef.current) ro.observe(containerRef.current);
    window.addEventListener("scroll", update, true);
    window.addEventListener("resize", update);
    return ()=>{
      ro.disconnect();
      window.removeEventListener("scroll", update, true);
      window.removeEventListener("resize", update);
    };
  }, [layoutRows, tasks]);

  function calcRowFromY(clientY){
    if(!scrollRef.current) return 0;
    const rect = scrollRef.current.getBoundingClientRect();
    const y = clientY - rect.top + scrollRef.current.scrollTop;
    let acc = 0, row = 0;
    for(const r of layoutRows){
      const h = r.type==='main' ? ROW_H : r.lanesCount * SUB_ROW_H;
      if(r.type==='main'){
        if(y < acc + h) return row;
        row++;
      }
      acc += h;
    }
    return row;
  }

  function animate(){
    const d = dragRef.current;
    if(!d) return;
    if(d.type === 'move'){
      if(d.active){
        const tx = d.dx;
        const currentRow = calcRowFromY(d.startY + d.dy);
        const ty = (currentRow - d.startRow) * d.rowHeight;
        d.node.style.transform = `translate3d(${tx}px,${ty}px,0)`;
      }
    }else if(d.type === 'left'){
      const width = Math.max(colW, d.startWidth - d.dx);
      d.node.style.transform = `translate3d(${d.dx}px,0,0)`;
      d.node.style.width = width + 'px';
      const font = fontPxFor(width, d.title);
      d.node.style.setProperty('--task-font', font + 'px');
      if(width < BULLET_HIDE_W) d.node.classList.add('hide-bullet'); else d.node.classList.remove('hide-bullet');
    }else if(d.type === 'right'){
      const width = Math.max(colW, d.startWidth + d.dx);
      d.node.style.width = width + 'px';
      const font = fontPxFor(width, d.title);
      d.node.style.setProperty('--task-font', font + 'px');
      if(width < BULLET_HIDE_W) d.node.classList.add('hide-bullet'); else d.node.classList.remove('hide-bullet');
    }
    rafRef.current = requestAnimationFrame(animate);
  }

  const sendDragMove = throttle((taskId, dxPx) => {
    const ch = chanRef.current; if(!ch) return;
    const deltaWeeks = Math.round(dxPx / colW);
    ch.send({ type:"broadcast", event:"drag", payload: { t:"move", taskId, from:IDENTITY.id, deltaWeeks, by:IDENTITY.pseudo, color:IDENTITY.color }});
  }, 40);

  function startDrag(e, t, type, rowHeight, g){
    e.preventDefault();
    const node = e.target.closest('.task-bar');
    if(!node) return;
    node.setPointerCapture(e.pointerId);
    dragRef.current = {
      taskId: t.id,
      type,
      startX: e.clientX,
      startY: e.clientY,
      dx: 0,
      dy: 0,
      node,
      pointerId: e.pointerId,
      startWidth: g.width,
      rowHeight,
      title: t.title,
      active: type !== 'move',
      downAt: performance.now(),
      startRow: calcRowFromY(e.clientY)
    };
    if(dragRef.current.active){
      node.classList.add('is-dragging');
      node.style.willChange = 'transform,width';
      document.body.classList.add('is-dragging');
    }
    // broadcast start
    const ch = chanRef.current;
    if (ch && type === 'move') {
      ch.send({ type:"broadcast", event:"drag", payload:{ t:"start", taskId:t.id, from:IDENTITY.id, by:IDENTITY.pseudo, color:IDENTITY.color }});
    }

    function onMove(ev){
      const d = dragRef.current; if(!d) return;
      d.dx = ev.clientX - d.startX;
      d.dy = ev.clientY - d.startY;
      if(!d.active){
        const elapsed = performance.now() - d.downAt;
        if((Math.abs(d.dx) > DRAG_THRESHOLD_PX || Math.abs(d.dy) > DRAG_THRESHOLD_PX) && elapsed > DRAG_THRESHOLD_MS){
          d.active = true;
          d.node.classList.add('is-dragging');
          d.node.style.willChange = 'transform,width';
          document.body.classList.add('is-dragging');
        }
      }
      if (d.type === 'move') sendDragMove(d.taskId, d.dx);
    }

    function end(ev, cancel=false){
      const d = dragRef.current; if(!d) return;
      dragHappenedRef.current = d.active;
      dragRef.current = null;
      cancelAnimationFrame(rafRef.current);
      window.removeEventListener('pointermove', onMove);
      window.removeEventListener('pointerup', onPointerUp);
      window.removeEventListener('keydown', onKey);
      d.node.releasePointerCapture(d.pointerId);
      d.node.classList.remove('is-dragging','hide-bullet');
      d.node.style.transform = '';
      d.node.style.width = d.startWidth + 'px';
      d.node.style.willChange = '';
      document.body.classList.remove('is-dragging');

      // broadcast end
      const ch = chanRef.current;
      if (ch && d.type === 'move') {
        ch.send({ type:"broadcast", event:"drag", payload:{ t:"end", taskId:d.taskId, from:IDENTITY.id, by:IDENTITY.pseudo, color:IDENTITY.color }});
      }

      if(cancel) return;
      if(!d.active || lastWasDblClickRef.current){ lastWasDblClickRef.current = false; return; }

      const dropX = ev.clientX, dropY = ev.clientY;
      setTasks(prev=>{
        const idx = prev.findIndex(x=>x.id===d.taskId); if(idx<0) return prev;
        const t0 = prev[idx];
        const deltaWeeks = Math.round(d.dx / colW);
        let ns = t0.startISO, ne = t0.endISO;
        if(d.type === 'move'){
          ns = addWeeksISO(t0.startISO, deltaWeeks, TIMELINE_START, TIMELINE_END);
          ne = addWeeksISO(t0.endISO,   deltaWeeks, TIMELINE_START, TIMELINE_END);
        }else if(d.type === 'left'){
          ns = addWeeksISO(t0.startISO, deltaWeeks, TIMELINE_START, new Date(t0.endISO));
        }else if(d.type === 'right'){
          ne = addWeeksISO(t0.endISO, deltaWeeks, new Date(t0.startISO), TIMELINE_END);
        }
        let targetParentId = null;
        for(const [pid, rect] of Object.entries(subZonesRef.current)){
          if(dropX>=rect.left && dropX<=rect.right && dropY>=rect.top && dropY<=rect.bottom){
            targetParentId = pid;
            break;
          }
        }
        const copy = prev.slice();
        if(targetParentId && targetParentId!==t0.id){
          const next = { ...t0, parentId: targetParentId, startISO: ns, endISO: ne, lastBy: IDENTITY.pseudo };
          delete next.row;
          copy[idx] = next;
          return copy;
        }
        const newTopRow = calcRowFromY(dropY);
        copy[idx] = { ...t0, parentId: null, row: newTopRow, startISO: ns, endISO: ne, lastBy: IDENTITY.pseudo };
        return copy;
      });
    }
    function onPointerUp(ev){ end(ev, false); }
    function onKey(ev){ if(ev.key === 'Escape'){ end(ev, true); } }
    window.addEventListener('pointermove', onMove);
    window.addEventListener('pointerup', onPointerUp);
    window.addEventListener('keydown', onKey);
    rafRef.current = requestAnimationFrame(animate);
  }

  /* --------- Actions diverses --------- */
  function toggleExpand(taskId){
    setTasks(prev => prev.map(t => t.id===taskId ? { ...t, expanded: !t.expanded } : t));
  }
  function removeTask(id){ setTasks(prev => prev.filter(t => t.id!==id && t.parentId!==id)); }
  function toggleCategory(id){ setCategories(prev => prev.map(c => c.id===id ? { ...c, enabled: !(c.enabled!==false)} : c )); }
  function updateCategoryColor(id,color){
    setCategories(prev => prev.map(c => c.id===id ? {...c, color} : c));
    setTasks(prev => prev.map(t => t.categoryId===id ? { ...t, color } : t));
  }
  function removeCategory(id){
    setCategories(prev => prev.filter(c => c.id !== id));
    setTasks(prev => prev.map(t => t.categoryId===id ? { ...t, categoryId:null } : t));
  }

  function addNote(e){
    e.preventDefault();
    if(!selectedTask || !newNote.trim()) return;
    setTasks(prev=>prev.map(t=>t.id===selectedTask.id?{...t,notes:[...t.notes,newNote.trim()]}:t));
    setNewNote("");
  }
  function removeNote(idx){
    if(!selectedTask) return;
    setTasks(prev=>prev.map(t=>t.id===selectedTask.id?{...t,notes:t.notes.filter((_,i)=>i!==idx)}:t));
  }

  /* --------- Ajout tâche --------- */
  const [newTask, setNewTask] = useState({
    title: "",
    startISO: toISODate(TIMELINE_START),
    endISO: toISODate(new Date(TIMELINE_START.getTime()+7*MS_DAY)),
    range: `${toISODate(TIMELINE_START)} → ${toISODate(new Date(TIMELINE_START.getTime()+7*MS_DAY))}`,
    color: "#2563eb",
    categoryId: "",
    newCategoryName: ""
  });
  function parseRange(v){
    const SEP = ["→"," — "," – "," to "," au "," -> "," - "];
    let a=null,b=null, s=v.trim();
    for(const sep of SEP){
      const i = s.indexOf(sep);
      if(i>=0){ a=s.slice(0,i).trim(); b=s.slice(i+sep.length).trim(); break; }
    }
    const ok = x=>x && x.length===10 && x[4]==="-" && x[7]==="-" && !isNaN(Date.parse(x));
    if(ok(a) && ok(b)) return {a,b};
    return null;
  }
  function addTask(e){
    e.preventDefault();
    const pr = parseRange(newTask.range);
    const sISO = pr ? pr.a : newTask.startISO;
    const eISO = pr ? pr.b : newTask.endISO;
    const s = new Date(sISO), eDate=new Date(eISO);
    if(s>eDate){ alert("La date de début doit précéder la date de fin."); return; }

    let chosenCat = categories.find(c=>c.id===newTask.categoryId);
    if(!chosenCat && newTask.newCategoryName.trim()){
      const exist = categories.find(c=>c.name.toLowerCase()===newTask.newCategoryName.trim().toLowerCase());
      chosenCat = exist || { id:`c-${Date.now()}-${Math.random().toString(36).slice(2,6)}`, name:newTask.newCategoryName.trim(), color:newTask.color, enabled:true };
      if(!exist) setCategories(prev=>[...prev, chosenCat]);
    }
    const color = chosenCat ? chosenCat.color : newTask.color;
    const t = {
      id: `t-${Date.now()}`,
      title: newTask.title || (chosenCat?chosenCat.name:"Sans titre"),
      startISO: toISODate(clampDate(s,TIMELINE_START,TIMELINE_END)),
      endISO:   toISODate(clampDate(eDate,TIMELINE_START,TIMELINE_END)),
      color,
      categoryId: chosenCat?.id || null,
      row: tasks.length,
      notes: [],
      parentId: null,
      expanded: false,
      lastBy: IDENTITY.pseudo
    };
    setTasks(prev=>[...prev, t]);
  }
  function TaskBar({t, draggable=true, onToggle, isExpanded=false, rowHeight=ROW_H, gap=ROW_GAP}){
    const g = taskGridInfo(t, visibleWeeks, colW);
    const isNarrow = g.width < BULLET_HIDE_W;
    const fontPx = fontPxFor(g.width, t.title);
    const barRef = useRef(null);
    useEffect(()=>{
      const el = barRef.current; if(!el) return;
      const update = () => {
        const w = el.getBoundingClientRect().width;
        const f = fontPxFor(w, t.title);
        el.style.setProperty('--task-font', f + 'px');
        if(w < BULLET_HIDE_W) el.classList.add('hide-bullet'); else el.classList.remove('hide-bullet');
      };
      update();
      const ro = new ResizeObserver(update);
      ro.observe(el);
      return () => ro.disconnect();
    }, [t.title]);
    return (
      <div className="pointer-events-none absolute left-0 top-0 w-full" style={{height: rowHeight}}>
        <div
          ref={barRef}
          className={"pointer-events-auto absolute select-none rounded-lg shadow-sm task-bar touch-none z-10" + (isNarrow ? " hide-bullet" : "")}
          data-taskid={t.id}
          style={{ left:g.left, width:g.width, top:gap/2, height:rowHeight-gap, backgroundColor:t.color, '--task-font': fontPx }}
          onDoubleClick={(e)=>{ e.preventDefault(); e.stopPropagation(); lastWasDblClickRef.current = true; setTimeout(()=>{ lastWasDblClickRef.current = false; },0); onToggle && onToggle(); }}
          onClick={(e)=>{ if(dragHappenedRef.current){ dragHappenedRef.current=false; return; } if(lastWasDblClickRef.current){ lastWasDblClickRef.current=false; return; } setSelectedTaskId(t.id); }}
          onPointerDown={(e)=>{ if(!draggable || e.button!==0 || e.detail>1 || e.target.closest('[data-no-drag]')) return; e.stopPropagation(); startDrag(e,t,'move',rowHeight,g); }}
          title={t.lastBy ? `Dernière modification par ${t.lastBy}` : undefined}
        >
          <div className="flex h-full items-center gap-1 pl-1 pr-2 text-slate-700" style={{fontSize:'var(--task-font)'}}>
            {onToggle && (
              <button
                data-no-drag
                onClick={(e)=>{e.stopPropagation(); onToggle();}}
                className="w-3 flex-none text-[10px]"
                title={isExpanded ? 'Replier' : 'Déplier'}
              >{isExpanded ? '▾' : '▸'}</button>
            )}
            <span className="bullet inline-block h-2 w-2 rounded" style={{backgroundColor:t.color}} />
            <span className="truncate min-w-0 font-medium" title={`${t.title} — ${t.startISO} → ${t.endISO}`}>{t.title}</span>
          </div>

          {draggable && (
            <>
              <div
                data-handle="left"
                onPointerDown={(e)=>{ e.stopPropagation(); startDrag(e,t,'left',rowHeight,g); }}
                className="absolute inset-y-0 left-0 w-2 cursor-w-resize touch-none"
                title="Ajuster début"
              ></div>
              <div
                data-handle="right"
                onPointerDown={(e)=>{ e.stopPropagation(); startDrag(e,t,'right',rowHeight,g); }}
                className="absolute inset-y-0 right-0 w-2 cursor-e-resize touch-none"
                title="Ajuster fin"
              ></div>
            </>
          )}
        </div>
      </div>
    );
  }
  /* --------- Rendu --------- */

  const gridCols = `repeat(${visibleWeeks.length}, ${colW}px)`;
  const headerBar = (
    <div className="sticky top-0 z-10 border-b border-slate-200 bg-white/90">
      <div style={{display:'grid', gridTemplateColumns:gridCols}}>
        {monthSegments.map((m,i)=>(
          <div key={`${m.label}-${i}`} className="flex items-center justify-center border-r border-slate-100 px-2 py-2 text-xs font-semibold uppercase tracking-wide text-slate-600" style={{gridColumn:`span ${m.span} / span ${m.span}`}}>
            {m.label}
          </div>
        ))}
      </div>
      <div className="border-t border-slate-100" style={{display:'grid', gridTemplateColumns:gridCols}}>
        {visibleWeeks.map((w,i)=>(
          <div key={i} className="flex items-center justify-center border-r border-slate-100 px-1 py-1 text-[10px] text-slate-500" title={`${fmtDM.format(w)} → ${fmtDM.format(new Date(w.getTime()+MS_DAY*6))}`}>
            S{String(getISOWeek(w)).padStart(2,'0')}
          </div>
        ))}
      </div>
    </div>
  );

  return (
    <div className="min-h-screen w-full overflow-x-hidden bg-gradient-to-br from-slate-50 to-slate-100 text-slate-900">
      <div
        className="mx-auto max-w-full px-2 py-4 h-[82vh]"
        style={{
          display:'grid',
          gridTemplateColumns: notesOpen ? '1fr 432px' : '1fr',
          gridTemplateRows:'auto 1fr',
          columnGap: notesOpen ? '24px' : '0px',
          rowGap:'24px'
        }}
      >
        {/* Top bar sur 2 colonnes */}
        <div style={{ gridColumn:'1 / -1', gridRow:1 }} className="flex items-start justify-between gap-3">
          <button
            onClick={() => setPanelOpen(v => !v)}
            className="inline-flex items-center gap-2 rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm font-medium text-slate-800 shadow-sm hover:bg-slate-50"
          >
            <span style={{fontSize:18}}>☰</span> Planificateur
          </button>

          <div className="flex items-center gap-2">
            <div className="flex items-center gap-2">
              {presence.map(p=>(
                <span key={p.id}
                  className="inline-flex items-center gap-1 rounded-full border px-2 py-0.5 text-xs"
                  style={{ borderColor:p.color, color:p.color }}
                  title={p.pseudo}
                >
                  <span className="inline-block h-2 w-2 rounded-full" style={{ backgroundColor:p.color }}></span>
                  {p.pseudo}
                </span>
              ))}
            </div>
            <img src="logo.png" alt="Logo" className="h-12 w-auto" />
          </div>
        </div>

        {/* Gantt gauche, ligne 2 */}
        <div className="relative" style={{ gridColumn:'1', gridRow:2 }}>
          {selectedTask && (
            <div className="absolute top-0 right-0 translate-x-full flex flex-col gap-1 p-1">
              {selectedTask.parentId && (
                <button
                  className="rounded border border-slate-300 bg-white px-1 text-[10px] hover:bg-slate-50"
                  title="Retirer de la sous-frise"
                  onClick={() => setTasks(prev => prev.map(x => x.id === selectedTask.id ? { ...x, parentId: null, lastBy: IDENTITY.pseudo } : x))}
                >↶</button>
              )}
              <button
                className="rounded border border-red-200 bg-white px-1 text-[10px] text-red-700 hover:bg-red-50"
                title="Supprimer"
                onClick={() => { removeTask(selectedTask.id); setSelectedTaskId(null); }}
              >🗑</button>
            </div>
          )}

          <div
            ref={containerRef}
            className="overflow-hidden rounded-2xl border border-slate-200 bg-white shadow-sm h-full max-h-full flex flex-col min-h-0"
          >
            {visibleWeeks.length === 0 ? null : headerBar}

            <div className="min-h-0 flex-1 overflow-auto" ref={scrollRef}>
            {/* Lignes dynamiques */}
            {layoutRows.map((row,i)=>{
              if(row.type==='main'){
                const rowTasks = filteredTop.filter(t => (t.row||0)===row.row);
                return (
                  <div key={`main-${i}`} className="relative border-b border-slate-100" style={{ display:'grid', gridTemplateColumns:gridCols, height: ROW_H }}>
                    {visibleWeeks.map((_,ci)=><div key={ci} className={(ci%2===0?"border-slate-50":"border-slate-100")+" border-r"} />)}
                    {rowTasks.map(t=>(
                      <TaskBar
                        key={t.id}
                        t={t}
                        draggable={true}
                        onToggle={()=>toggleExpand(t.id)}
                        isExpanded={t.expanded}
                      />
                    ))}
                  </div>
                );
              }

              // Sous-frise
              const parent = tasks.find(t=>t.id===row.parentId);
              if(!parent) return null;
              const children = tasks.filter(t=>t.parentId===row.parentId);
              const packed = packLanes(children, visibleWeeks, colW);

              return (
                <div
                  key={`sub-${i}`}
                  className="relative border-b border-slate-100 bg-white"
                  style={{ display:'grid', gridTemplateColumns:gridCols, height: packed.lanesCount * SUB_ROW_H }}
                  data-subzone="1"
                  data-parentid={row.parentId}
                  title="Sous-frise : déposez une tâche ici pour l’ajouter"
                >
                  {/* fond */}
                  {Array.from({length: packed.lanesCount}).map((_,laneIdx)=>(
                    <div key={laneIdx} className="absolute left-0 right-0" style={{ top: laneIdx*SUB_ROW_H, height: SUB_ROW_H }}>
                      <div style={{display:'grid', gridTemplateColumns:gridCols, height:'100%'}}>
                        {visibleWeeks.map((_,ci)=><div key={ci} className={(ci%2===0?"border-slate-50":"border-slate-100")+" border-r"} />)}
                      </div>
                    </div>
                  ))}
                  {/* sous-tâches */}
                  {packed.placed.map(p=>(
                    <div key={p.t.id} className="pointer-events-none absolute left-0 top-0 w-full" style={{ height: SUB_ROW_H, transform:`translateY(${p.lane*SUB_ROW_H}px)` }}>
                      <TaskBar t={p.t} draggable={true} rowHeight={SUB_ROW_H} gap={SUB_ROW_GAP} />
                    </div>
                  ))}
                </div>
              );
            })}
          </div>
        </div>
      </div>

        {/* Notes droite */}
        {notesOpen && (
          <aside
          className="h-full border-l border-slate-200 bg-white rounded-2xl shadow-sm flex flex-col min-h-0"
          style={{ gridColumn:'2', gridRow:2 }}
          aria-labelledby="notes-title"
        >
          <div className="flex items-center justify-between border-b border-slate-200 px-4 py-3">
            <div id="notes-title" className="font-medium text-slate-700">{selectedTask ? selectedTask.title : 'Notes'}</div>
            <button onClick={()=>setNotesOpen(false)} className="rounded-full border border-slate-300 bg-white px-2 py-1 text-sm text-slate-700 hover:bg-slate-50" aria-label="Masquer les notes">❯</button>
          </div>
          <div className="p-4 space-y-4 flex-1 overflow-y-auto">
            {selectedTask ? (
              <>
                {selectedTask.notes.length>0 ? (
                  <ul className="space-y-2">
                    {selectedTask.notes.map((n,i)=>(
                      <li key={i} className="flex items-start gap-2">
                        <span className="flex-1 text-sm" dangerouslySetInnerHTML={{__html: marked.parse(n)}}></span>
                        <button className="text-xs text-red-600" onClick={()=>removeNote(i)} title="Supprimer">🗑</button>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-sm text-slate-500">Aucune note</p>
                )}
                <form onSubmit={addNote} className="space-y-2">
                  <textarea className="w-full rounded border border-slate-300 p-2 text-sm" rows="4" value={newNote} onChange={e=>setNewNote(e.target.value)} placeholder="Écrire en Markdown" />
                  <button type="submit" className="rounded bg-slate-800 px-3 py-1 text-sm font-medium text-white hover:bg-slate-700">Ajouter</button>
                </form>
              </>
            ) : (
              <p className="text-sm text-slate-500">Sélectionnez une tâche pour voir ses notes.</p>
            )}
          </div>
          </aside>
        )}
      </div>
      {!notesOpen && (
        <button
          onClick={()=>setNotesOpen(true)}
          className="fixed right-0 top-1/2 z-40 -translate-y-1/2 transform rounded-l-lg border border-slate-300 bg-white px-3 py-2 text-sm text-slate-700 shadow"
        >
          Notes
        </button>
      )}
        {categories.length>0 && (
        <footer className="w-full max-w-full mx-auto px-2 pb-4">
          <div className="flex flex-wrap items-center gap-2">
            {categories.map(c=>(
              <div key={c.id} className="inline-flex items-center gap-2 rounded-full border border-slate-300 bg-white px-3 py-1 text-sm shadow-sm">
                <input type="checkbox" checked={c.enabled !== false} onChange={()=>toggleCategory(c.id)} className="h-4 w-4 accent-slate-900" />
                <label className="relative" title={c.color}>
                  <input type="color" value={c.color} onChange={(e)=>updateCategoryColor(c.id, e.target.value)} className="absolute inset-0 h-3 w-3 opacity-0 cursor-pointer" />
                  <span className="inline-block h-3 w-3 rounded-full" style={{backgroundColor:c.color}} />
                </label>
                <span className="font-medium">{c.name}</span>
                <span className="text-xs text-slate-500">{c.color}</span>
                <button onClick={()=>removeCategory(c.id)} className="ml-1 text-xs text-slate-400 hover:text-red-600" title="Supprimer">✕</button>
              </div>
            ))}
          </div>
        </footer>
      )}

        {/* Panneau latéral (ajout) */}
        {panelOpen && (
          <div className="fixed inset-0 z-50">
            <div className="absolute inset-0 bg-black/20" onClick={()=>setPanelOpen(false)} />
            <aside className="absolute left-0 top-0 h-full w-[380px] max-w-[90vw] overflow-y-auto border-r border-slate-200 bg-white shadow-xl" onClick={e=>e.stopPropagation()}>
              <div className="sticky top-0 z-10 flex items-center justify-between border-b border-slate-200 bg-white px-4 py-3">
                <div className="font-medium">Planificateur</div>
                <button onClick={()=>setPanelOpen(false)} className="rounded-full border border-slate-300 bg-white px-2 py-1 text-sm text-slate-700 hover:bg-slate-50" aria-label="Fermer">✕</button>
              </div>

              <div className="p-4 space-y-4">
                <form onSubmit={addTask} className="rounded-xl border border-slate-200 bg-white p-4 shadow-sm">
                  <h2 className="mb-2 text-sm font-medium text-slate-700">Ajouter une ligne</h2>
                  <label className="text-sm block mb-2">Intitulé
                    <input className="mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-slate-400" value={newTask.title} onChange={e=>setNewTask(s=>({...s,title:e.target.value}))} placeholder="Ex. Semaine de tournage" />
                  </label>
                  <label className="text-sm block mb-2">Plage de dates
                    <input className="mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-slate-400" value={newTask.range} onChange={e=>setNewTask(s=>({...s,range:e.target.value}))} placeholder="2025-09-06 → 2025-09-22" />
                  </label>
                  <div className="grid grid-cols-2 gap-3 mb-2">
                    <label className="text-sm">Catégorie
                      <select className="mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-slate-400" value={newTask.categoryId} onChange={e=>setNewTask(s=>({...s,categoryId:e.target.value}))}>
                        <option value="">— Aucune —</option>
                        {categories.map(c=>(<option key={c.id} value={c.id}>{c.name}</option>))}
                      </select>
                    </label>
                    <label className="text-sm">Couleur (si pas de catégorie)
                      <input type="color" className="mt-1 h-10 w-full cursor-pointer rounded-lg border border-slate-300" value={newTask.color} onChange={e=>setNewTask(s=>({...s,color:e.target.value}))} />
                    </label>
                  </div>
                  <label className="text-sm block mb-3">Dénomination (si nouvelle couleur)
                    <input className="mt-1 w-full rounded-lg border border-slate-300 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-slate-400" value={newTask.newCategoryName} onChange={e=>setNewTask(s=>({...s,newCategoryName:e.target.value}))} placeholder="Ex. Montage" />
                  </label>
                  <button type="submit" className="inline-flex items-center justify-center rounded-xl bg-slate-900 px-3 py-2 text-sm font-medium text-white hover:bg-slate-800">Ajouter la ligne</button>
                </form>

                <div className="flex gap-2">
                  <button
                    className="rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm hover:bg-slate-50"
                    onClick={()=>{ const data=JSON.stringify({categories,tasks}); navigator.clipboard.writeText(data).then(()=>alert("État copié.")); }}
                  >Exporter</button>
                  <button
                    className="rounded-lg border border-slate-300 bg-white px-3 py-2 text-sm hover:bg-slate-50"
                    onClick={()=>{
                      const txt = prompt("Collez le JSON :");
                      if(!txt) return;
                      try{
                        const s=JSON.parse(txt);
                        if(s.categories) setCategories(s.categories);
                        if(s.tasks) setTasks(s.tasks.map((t,i)=>({
                          ...t,
                          row: typeof t.row==='number' ? t.row : i,
                          notes: Array.isArray(t.notes) ? t.notes : [],
                          expanded: !!t.expanded,
                          parentId: t.parentId || null
                        })));
                        setPanelOpen(false);
                      }catch{ alert("JSON invalide"); }
                    }}
                  >Importer</button>
                  <button
                    className="rounded-lg bg-slate-900 px-3 py-2 text-sm font-medium text-white hover:bg-slate-800"
                    onClick={()=>{ const url=location.origin+location.pathname+location.search+'#s='+b64Encode(JSON.stringify({categories,tasks})); window.open(url,'_blank'); setPanelOpen(false); }}
                  >Nouveau (→ transfère)</button>
                </div>
                <div className="mt-8 flex flex-col items-center">
                  <img src="scan-me.png" alt="QR code pour accéder à l'outil" className="w-40 h-40" />
                  <p className="mt-2 text-sm text-slate-600">scan me</p>
                </div>
              </div>
            </aside>
          </div>
        )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<PlannerApp />);
    </script>
  </body>
</html>
